C51 COMPILER V9.60.0.0   CH552_UART_FIFO                                                   04/19/2024 22:11:44 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CH552_UART_FIFO
OBJECT MODULE PLACED IN .\Objects\CH552_UART_FIFO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE CH552_UART_FIFO.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\CH552_UART_FIFO.lst) OBJECT(.\Objects\CH552_UART_FIFO.obj)

line level    source

   1          #include "CH552.H"
   2          #include "CH552_UART_FIFO.h"
   3          
   4          volatile UINT8 uart0_rx_buf[UART_RX_BUF_SIZE];
   5          volatile UINT8 uart1_rx_buf[UART_RX_BUF_SIZE];
   6          
   7          volatile UINT8 uart0_tx_buf[UART_TX_BUF_SIZE];
   8          volatile UINT8 uart1_tx_buf[UART_TX_BUF_SIZE];
   9          
  10          
  11          volatile UINT8* uart_rx_bufs[2] = {uart0_rx_buf, uart1_rx_buf};
  12          volatile UINT16 uart_rx_counts[2] = {0};
  13          volatile UINT16 uart_rx_fronts[2] = {0};
  14          volatile UINT16 uart_rx_backs[2] = {0};
  15          
  16          volatile UINT8* uart_tx_bufs[2] = {uart0_tx_buf, uart1_tx_buf};
  17          volatile UINT16 uart_tx_counts[2] = {0};
  18          volatile UINT16 uart_tx_fronts[2] = {0};
  19          volatile UINT16 uart_tx_backs[2] = {0};
  20          
  21          
  22          // #############################
  23          // ########## RECEIVE ##########
  24          // #############################
  25          //no need to disable interrupts before calling
  26          UINT16 uart_rx_num_used(UINT8 uart_idx)
  27          {
  28   1              return uart_rx_counts[uart_idx];
  29   1      }
  30          
  31          //disable UART interrupts before calling (from user code..)
  32          UINT16 uart_rx_num_free(UINT8 uart_idx)
  33          {
  34   1              return (UART_RX_BUF_SIZE - uart_rx_counts[uart_idx]);
  35   1      }
  36          
  37          //no need to disable interrupts before calling
  38          UINT8 uart_rx_empty(UINT8 uart_idx)
  39          {
  40   1              return uart_rx_counts[uart_idx] == 0;
  41   1      }
  42          
  43          //disable UART interrupts before calling (from user code..)
  44          UINT8 uart_rx_full(UINT8 uart_idx)
  45          {
  46   1              return uart_rx_counts[uart_idx] >= UART_RX_BUF_SIZE;
  47   1      }
  48          
  49          //disable UART interrupts before calling (from user code..)
  50          UINT8 uart_rx_push(UINT8 uart_idx, UINT8 val) reentrant
  51          {
  52   1              if(uart_rx_full(uart_idx))
  53   1              {
  54   2                      return 0; // FIFO full
C51 COMPILER V9.60.0.0   CH552_UART_FIFO                                                   04/19/2024 22:11:44 PAGE 2   

  55   2              }
  56   1      
  57   1              uart_rx_bufs[uart_idx][uart_rx_backs[uart_idx]] = val;
  58   1              ++uart_rx_backs[uart_idx];
  59   1              uart_rx_backs[uart_idx] &= (UART_RX_BUF_SIZE - 1); // Handle wrap-around
  60   1              ++uart_rx_counts[uart_idx];
  61   1      
  62   1              return 1;
  63   1      }
  64          
  65          //disable UART interrupts before calling (from user code..)
  66          UINT8 uart_rx_pop(UINT8 uart_idx)
  67          {
  68   1              UINT8 val;
  69   1              if(uart_rx_empty(uart_idx))
  70   1              {
  71   2                      return 0; // Nothing in FIFO
  72   2              }
  73   1      
  74   1              val = uart_rx_bufs[uart_idx][uart_rx_fronts[uart_idx]];
  75   1              ++uart_rx_fronts[uart_idx];
  76   1              uart_rx_fronts[uart_idx] &= (UART_RX_BUF_SIZE - 1); // Handle wrap-around
  77   1              --uart_rx_counts[uart_idx];
  78   1      
  79   1              return val;
  80   1      }
  81          
  82          //no need to disable interrupts before calling
  83          UINT8 uart_rx_peek(UINT8 uart_idx)
  84          {
  85   1              if(uart_rx_empty(uart_idx))
  86   1              {
  87   2                      return 0; // Nothing in FIFO
  88   2              }
  89   1      
  90   1              return uart_rx_bufs[uart_idx][uart_rx_fronts[uart_idx]];
  91   1      }
  92          
  93          //disable UART interrupts before calling (from user code..)
  94          UINT8 uart_rx_read(UINT8 uart_idx, UINT8* dest, UINT16 num_bytes)
  95          {
  96   1              if(num_bytes > uart_rx_counts[uart_idx])
  97   1              {
  98   2                      return 0; // Not enough data to read
  99   2              }
 100   1      
 101   1              // Read from FIFO to dest
 102   1              uart_rx_counts[uart_idx] -= num_bytes;
 103   1              while(num_bytes)
 104   1              {
 105   2                      *dest = uart_rx_bufs[uart_idx][uart_rx_fronts[uart_idx]];
 106   2                      ++uart_rx_fronts[uart_idx];
 107   2                      uart_rx_fronts[uart_idx] &= (UART_RX_BUF_SIZE - 1); // Handle wrap-around
 108   2                      ++dest;
 109   2                      --num_bytes;
 110   2              }
 111   1      
 112   1              return 1;
 113   1      }
 114          
 115          //disable UART interrupts before calling (from user code..)
 116          UINT8 uart_rx_write(UINT8 uart_idx, UINT8* src, UINT16 num_bytes)
C51 COMPILER V9.60.0.0   CH552_UART_FIFO                                                   04/19/2024 22:11:44 PAGE 3   

 117          {
 118   1              if(num_bytes > (UART_RX_BUF_SIZE - uart_rx_counts[uart_idx]))
 119   1              {
 120   2                      return 0; // Not enough space to write
 121   2              }
 122   1      
 123   1              // Write to FIFO from src
 124   1              uart_rx_counts[uart_idx] += num_bytes;
 125   1              while(num_bytes)
 126   1              {
 127   2                      uart_rx_bufs[uart_idx][uart_rx_backs[uart_idx]] = *src;
 128   2                      ++uart_rx_backs[uart_idx];
 129   2                      uart_rx_backs[uart_idx] &= (UART_RX_BUF_SIZE - 1); // Handle wrap-around
 130   2                      ++src;
 131   2                      --num_bytes;
 132   2              }
 133   1      
 134   1              return 1;
 135   1      }
 136          
 137          // ##############################
 138          // ########## TRANSMIT ##########
 139          // ##############################
 140          //no need to disable interrupts before calling
 141          UINT16 uart_tx_num_used(UINT8 uart_idx)
 142          {
 143   1              return uart_tx_counts[uart_idx];
 144   1      }
 145          
 146          //no need to disable interrupts before calling
 147          UINT16 uart_tx_num_free(UINT8 uart_idx)
 148          {
 149   1              return (UART_TX_BUF_SIZE - uart_tx_counts[uart_idx]);
 150   1      }
 151          
 152          //no need to disable interrupts before calling
 153          UINT8 uart_tx_empty(UINT8 uart_idx)
 154          {
 155   1              return uart_tx_counts[uart_idx] == 0;
 156   1      }
 157          
 158          //no need to disable interrupts before calling
 159          UINT8 uart_tx_full(UINT8 uart_idx)
 160          {
 161   1              return uart_tx_counts[uart_idx] >= UART_TX_BUF_SIZE;
 162   1      }
 163          
 164          //disable UART interrupts before calling (from user code..)
 165          UINT8 uart_tx_push(UINT8 uart_idx, UINT8 val)
 166          {
 167   1              if(uart_tx_full(uart_idx))
 168   1              {
 169   2                      return 0; // FIFO full
 170   2              }
 171   1      
 172   1              uart_tx_bufs[uart_idx][uart_tx_backs[uart_idx]] = val;
 173   1              ++uart_tx_backs[uart_idx];
 174   1              uart_tx_backs[uart_idx] &= (UART_TX_BUF_SIZE - 1); // Handle wrap-around
 175   1              ++uart_tx_counts[uart_idx];
 176   1      
 177   1              return 1;
 178   1      }
C51 COMPILER V9.60.0.0   CH552_UART_FIFO                                                   04/19/2024 22:11:44 PAGE 4   

 179          
 180          //disable UART interrupts before calling (from user code..)
 181          UINT8 uart_tx_pop(UINT8 uart_idx) reentrant
 182          {
 183   1              UINT8 val;
 184   1              if(uart_tx_empty(uart_idx))
 185   1              {
 186   2                      return 0; // Nothing in FIFO
 187   2              }
 188   1      
 189   1              val = uart_tx_bufs[uart_idx][uart_tx_fronts[uart_idx]];
 190   1              ++uart_tx_fronts[uart_idx];
 191   1              uart_tx_fronts[uart_idx] &= (UART_TX_BUF_SIZE - 1); // Handle wrap-around
 192   1              --uart_tx_counts[uart_idx];
 193   1      
 194   1              return val;
 195   1      }
 196          
 197          //no need to disable interrupts before calling
 198          UINT8 uart_tx_peek(UINT8 uart_idx)
 199          {
 200   1              if(uart_tx_empty(uart_idx))
 201   1              {
 202   2                      return 0; // Nothing in FIFO
 203   2              }
 204   1      
 205   1              return uart_tx_bufs[uart_idx][uart_tx_fronts[uart_idx]];
 206   1      }
 207          
 208          //disable UART interrupts before calling (from user code..)
 209          UINT8 uart_tx_read(UINT8 uart_idx, UINT8* dest, UINT16 num_bytes)
 210          {
 211   1              if(num_bytes > uart_tx_counts[uart_idx])
 212   1              {
 213   2                      return 0; // Not enough data to read
 214   2              }
 215   1      
 216   1              // Read from FIFO to dest
 217   1              uart_tx_counts[uart_idx] -= num_bytes;
 218   1              while(num_bytes)
 219   1              {
 220   2                      *dest = uart_tx_bufs[uart_idx][uart_tx_fronts[uart_idx]];
 221   2                      ++uart_tx_fronts[uart_idx];
 222   2                      uart_tx_fronts[uart_idx] &= (UART_TX_BUF_SIZE - 1); // Handle wrap-around
 223   2                      ++dest;
 224   2                      --num_bytes;
 225   2              }
 226   1      
 227   1              return 1;
 228   1      }
 229          
 230          //disable UART interrupts before calling (from user code..)
 231          UINT8 uart_tx_write(UINT8 uart_idx, UINT8* src, UINT16 num_bytes)
 232          {
 233   1              if(num_bytes > (UART_TX_BUF_SIZE - uart_tx_counts[uart_idx]))
 234   1              {
 235   2                      return 0; // Not enough space to write
 236   2              }
 237   1      
 238   1              // Write to FIFO from src
 239   1              uart_tx_counts[uart_idx] += num_bytes;
 240   1              while(num_bytes)
C51 COMPILER V9.60.0.0   CH552_UART_FIFO                                                   04/19/2024 22:11:44 PAGE 5   

 241   1              {
 242   2                      uart_tx_bufs[uart_idx][uart_tx_backs[uart_idx]] = *src;
 243   2                      ++uart_tx_backs[uart_idx];
 244   2                      uart_tx_backs[uart_idx] &= (UART_TX_BUF_SIZE - 1); // Handle wrap-around
 245   2                      ++src;
 246   2                      --num_bytes;
 247   2              }
 248   1      
 249   1              return 1;
 250   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1918    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     68      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
