C51 COMPILER V9.60.0.0   MAIN                                                              04/16/2024 08:21:14 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "CH552.H"
   2          #include "System.h"
   3          #include "CH552_GPIO.h"
   4          #include "CH552_UART.h"
   5          #include "CH552_SPI.h"
   6          #include "CH552_TIMER.h"
   7          #include "CH552_I2C.h"
   8          
   9          #define CMD_NOP 0x00                    //Expects 0 bytes, returns 0
  10          #define CMD_TEST 0x01                   //Expects 1 byte, returns 1
  11          #define CMD_BAUD 0x02                   //Expects 2 bytes, returns 0
  12                  
  13          #define CMD_SPI_SPEED 0x03              //Expects 1 byte, returns 0
  14          #define CMD_SPI_MODE 0x04               //Expects 1 byte, returns 0
  15          #define CMD_SPI_CHIPSEL 0x05    //Expects 1 byte, returns 0
  16          #define CMD_SPI_TRANSFER 0x06   //Expects 1 byte, returns 1
  17                  
  18          #define CMD_I2C_SPEED 0x07              //Expects 2 bytes, returns 0
  19          #define CMD_I2C_START 0x08              //Expects 0 bytes, returns 0
  20          #define CMD_I2C_STOP 0x09               //Expects 0 bytes, returns 0
  21          #define CMD_I2C_WRITE 0x0A              //Expects 1 byte, returns 0
  22          #define CMD_I2C_READ 0x0B               //Expects 0 bytes, returns 1
  23          #define CMD_I2C_HOST_ACK 0x0C   //Expects 1 byte, returns 0
  24          #define CMD_I2C_AGENT_ACK 0x0D  //Expects 0 bytes, returns 1
  25                  
  26          char code test_string[] = "Booba";
  27          
  28          //Pins:
  29          // LED = P11
  30          // SCS = P14
  31          // MOSI = P15
  32          // MISO = P16
  33          // SCK = P17
  34          // RXD = P30
  35          // TXD = P31
  36          // SDA = P33
  37          // SCL = P34
  38          
  39          //TODO: Timer library does not work well at small timescales... need to optimize
  40          int main()
  41          {
  42   1              UINT8 temp;
  43   1              UINT32 baud_temp;
  44   1              UINT8 spi_speed = 4;
  45   1              UINT8 spi_mode = SPI_MODE_0;
  46   1              UINT8 cmd_count = 0;
  47   1              
  48   1              CfgFsys();      //CH559 clock selection configuration
  49   1              
  50   1              gpio_set_mode(GPIO_MODE_PP, GPIO_PORT_1, GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_7);
  51   1              gpio_set_mode(GPIO_MODE_INPUT, GPIO_PORT_1, GPIO_PIN_6);
  52   1              spi_init(4, SPI_MODE_0);
  53   1              
  54   1              gpio_set_mode(GPIO_MODE_OD_PU, GPIO_PORT_3, GPIO_PIN_3 | GPIO_PIN_4);
C51 COMPILER V9.60.0.0   MAIN                                                              04/16/2024 08:21:14 PAGE 2   

  55   1              i2c_init(GPIO_PORT_3, GPIO_PIN_3, GPIO_PORT_3, GPIO_PIN_4);
  56   1              
  57   1              gpio_set_mode(GPIO_MODE_PP, GPIO_PORT_3, GPIO_PIN_1);
  58   1              gpio_set_mode(GPIO_MODE_INPUT, GPIO_PORT_3, GPIO_PIN_0);
  59   1              uart0_init(TIMER_1, BUAD_RATE, UART_0_P30_P31);
  60   1              
  61   1              timer_init(TIMER_0, NULL);
  62   1              timer_set_period(TIMER_0, FREQ_SYS / 1000ul);   //period is 1ms
  63   1              EA = 1; //enable interupts
  64   1              E_DIS = 0;
  65   1              
  66   1              //Blink LED once
  67   1              gpio_clear_pin(GPIO_PORT_1, GPIO_PIN_1);
  68   1              timer_long_delay(TIMER_0, 250);
  69   1              gpio_set_pin(GPIO_PORT_1, GPIO_PIN_1);
  70   1              timer_long_delay(TIMER_0, 250);
  71   1              uart_write_string(UART_0, test_string);
  72   1              
  73   1              while(TRUE)
  74   1              {       
  75   2                      if(uart_bytes_available(UART_0))
  76   2                      {
  77   3                              temp = uart_read_byte(UART_0);
  78   3                              switch(temp)
  79   3                              {
  80   4                                      case CMD_NOP:
  81   4                                              break;
  82   4                                      case CMD_TEST:
  83   4                                              temp = uart_read_byte(UART_0);
  84   4                                              uart_write_byte(UART_0, temp);
  85   4                                              break;
  86   4                                      case CMD_BAUD:
  87   4                                              baud_temp = 0;
  88   4                                              baud_temp |= uart_read_byte(UART_0);
  89   4                                              baud_temp = baud_temp << 8;
  90   4                                              baud_temp |= uart_read_byte(UART_0);
  91   4                                              baud_temp = baud_temp << 7;
  92   4                                              uart0_init(TIMER_1, baud_temp, UART_0_P30_P31);
  93   4                                              break;
  94   4                                      case CMD_SPI_SPEED:
  95   4                                              spi_speed = uart_read_byte(UART_0);
  96   4                                              spi_init(spi_speed, spi_mode);
  97   4                                              break;
  98   4                                      case CMD_SPI_MODE:
  99   4                                              temp = uart_read_byte(UART_0);
 100   4                                              if(temp == 3)
 101   4                                                      spi_mode = SPI_MODE_3;
 102   4                                              else
 103   4                                                      spi_mode = SPI_MODE_0;
 104   4                                              spi_init(spi_speed, spi_mode);
 105   4                                              break;
 106   4                                      case CMD_SPI_CHIPSEL:
 107   4                                              temp = uart_read_byte(UART_0);
 108   4                                              gpio_write_pin(GPIO_PORT_1, GPIO_PIN_4, temp);
 109   4                                              break;
 110   4                                      case CMD_SPI_TRANSFER:
 111   4                                              temp = uart_read_byte(UART_0);
 112   4                                              temp = spi_transfer(temp);
 113   4                                              uart_write_byte(UART_0, temp);
 114   4                                              break;
 115   4                                      case CMD_I2C_SPEED:
 116   4                                              (void)uart_read_byte(UART_0);
C51 COMPILER V9.60.0.0   MAIN                                                              04/16/2024 08:21:14 PAGE 3   

 117   4                                              (void)uart_read_byte(UART_0);
 118   4                                              break;
 119   4                                      case CMD_I2C_START:
 120   4                                              i2c_start();
 121   4                                              break;
 122   4                                      case CMD_I2C_STOP:
 123   4                                              i2c_stop();
 124   4                                              break;
 125   4                                      case CMD_I2C_WRITE:
 126   4                                              temp = uart_read_byte(UART_0);
 127   4                                              i2c_write(temp);
 128   4                                              break;
 129   4                                      case CMD_I2C_READ:
 130   4                                              temp = i2c_read();
 131   4                                              uart_write_byte(UART_0, temp);
 132   4                                              break;
 133   4                                      case CMD_I2C_HOST_ACK:
 134   4                                              host_ack = uart_read_byte(UART_0);
 135   4                                              break;
 136   4                                      case CMD_I2C_AGENT_ACK:
 137   4                                              uart_write_byte(UART_0, agent_ack);
 138   4                                              break;
 139   4                                      default:
 140   4                                              break;
 141   4                              }
 142   3                              ++cmd_count;
 143   3                              gpio_write_pin(GPIO_PORT_1, GPIO_PIN_1, ~cmd_count & 0x01);
 144   3                      }
 145   2              }
 146   1      }
 147          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    627    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =   ----       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
