C51 COMPILER V9.60.0.0   CH552_TIMER                                                       04/18/2024 21:09:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CH552_TIMER
OBJECT MODULE PLACED IN .\Objects\CH552_TIMER.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE CH552_TIMER.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\CH552_TIMER.lst) OBJECT(.\Objects\CH552_TIMER.obj)

line level    source

   1          #include "CH552.H"
   2          #include "CH552_TIMER.h"
   3          
   4          UINT16 timer0_initial_count;
   5          UINT16 timer1_initial_count;
   6          
   7          //HINT: user can directly read and write the overflow counts
   8          volatile UINT16 timer_overflow_counts[3];
   9          
  10          void (*timer0_callback)(void) = NULL;
  11          void (*timer1_callback)(void) = NULL;
  12          void (*timer2_callback)(void) = NULL;
  13          
  14          void timer0_isr(void) interrupt INT_NO_TMR0
  15          {
  16   1              TL0 = (UINT8)timer0_initial_count;
  17   1              TH0 = timer0_initial_count >> 8;
  18   1              ++timer_overflow_counts[0];
  19   1              if(timer0_callback)
  20   1                      timer0_callback();
  21   1      }
  22          
  23          void timer1_isr(void) interrupt INT_NO_TMR1
  24          {
  25   1              TL1 = ((UINT8*)&timer1_initial_count)[0];
  26   1              TH1 = ((UINT8*)&timer1_initial_count)[1];
  27   1              ++timer_overflow_counts[1];
  28   1              if(timer1_callback)
  29   1                      timer1_callback();
  30   1      }
  31          
  32          void timer2_isr(void) interrupt INT_NO_TMR2
  33          {
  34   1              ++timer_overflow_counts[2];
  35   1              if(timer2_callback)
  36   1                      timer2_callback();
  37   1              TF2 = 0;
  38   1      }
  39          
  40          //HINT: timer_init stops the timer
  41          void timer_init(UINT8 timer, void (*callback)(void))
  42          {
  43   1              switch(timer)
  44   1              {
  45   2                      case TIMER_0:
  46   2                              TR0 = 0;
  47   2                              TMOD &= 0xF0;
  48   2                              TMOD |= bT0_M0;
  49   2                              T2MOD |= bTMR_CLK | bT0_CLK;
  50   2                              timer_overflow_counts[0] = 0;
  51   2                              timer0_callback = callback;
  52   2                              ET0 = 1;        //enable interrupts
  53   2                              break;
  54   2                      case TIMER_1:
C51 COMPILER V9.60.0.0   CH552_TIMER                                                       04/18/2024 21:09:17 PAGE 2   

  55   2                              TR1 = 0;
  56   2                              TMOD &= 0x0F;
  57   2                              TMOD |= bT1_M0;
  58   2                              T2MOD |= bTMR_CLK | bT1_CLK;
  59   2                              timer_overflow_counts[1] = 0;
  60   2                              timer1_callback = callback;
  61   2                              ET1 = 1;        //enable interrupts
  62   2                              break;
  63   2                      case TIMER_2:
  64   2                              T2CON = 0;
  65   2                              T2MOD &= 0xF0;
  66   2                              T2MOD |= bTMR_CLK | bT2_CLK;
  67   2                              timer_overflow_counts[2] = 0;
  68   2                              timer2_callback = callback;
  69   2                              ET2 = 1;        //enable interrupts
  70   2                              break;
  71   2                      default:
  72   2                              return;
  73   2              }
  74   1      }
  75          
  76          //HINT: if period is set to 0 the timer will count with a period of 65536
  77          void timer_set_period(UINT8 timer, UINT16 period)
  78          {
  79   1              UINT16 initial_count = ~period + 1;
  80   1              switch(timer)
  81   1              {
  82   2                      case TIMER_0:
  83   2                              timer0_initial_count = initial_count;
  84   2                              TL0 = (UINT8)initial_count;
  85   2                              TH0 = initial_count >> 8;
  86   2                              timer_overflow_counts[0] = 0;
  87   2                              break;
  88   2                      case TIMER_1:
  89   2                              timer1_initial_count = initial_count;
  90   2                              TL1 = (UINT8)initial_count;
  91   2                              TH1 = initial_count >> 8;
  92   2                              timer_overflow_counts[1] = 0;
  93   2                              break;
  94   2                      case TIMER_2:
  95   2                              RCAP2 = initial_count;
  96   2                              T2COUNT = initial_count;
  97   2                              timer_overflow_counts[2] = 0;
  98   2                              break;
  99   2                      default:
 100   2                              return;
 101   2              }
 102   1      }
 103          
 104          void timer_set_interrupt_enable(UINT8 timer, UINT8 ie)
 105          {
 106   1              switch(timer)
 107   1              {
 108   2                      case TIMER_0:
 109   2                              ET0 = ie ? 1 : 0;
 110   2                              break;
 111   2                      case TIMER_1:
 112   2                              ET1 = ie ? 1 : 0;
 113   2                              break;
 114   2                      case TIMER_2:
 115   2                              ET2 = ie ? 1 : 0;
 116   2                              break;
C51 COMPILER V9.60.0.0   CH552_TIMER                                                       04/18/2024 21:09:17 PAGE 3   

 117   2                      default:
 118   2                              return;
 119   2              }
 120   1      }
 121          
 122          void timer_start(UINT8 timer)
 123          {
 124   1              switch(timer)
 125   1              {
 126   2                      case TIMER_0:
 127   2                              TR0 = 1;
 128   2                              break;
 129   2                      case TIMER_1:
 130   2                              TR1 = 1;
 131   2                              break;
 132   2                      case TIMER_2:
 133   2                              TR2 = 1;
 134   2                              break;
 135   2                      default:
 136   2                              return;
 137   2              }
 138   1      }
 139          
 140          void timer_stop(UINT8 timer)
 141          {
 142   1              switch(timer)
 143   1              {
 144   2                      case TIMER_0:
 145   2                              TR0 = 0;
 146   2                              break;
 147   2                      case TIMER_1:
 148   2                              TR1 = 0;
 149   2                              break;
 150   2                      case TIMER_2:
 151   2                              TR2 = 0;
 152   2                              break;
 153   2                      default:
 154   2                              return;
 155   2              }
 156   1      }
 157          
 158          UINT16 timer_get_ticks(UINT8 timer)
 159          {
 160   1              UINT16 num_ticks;
 161   1              switch(timer)
 162   1              {
 163   2                      case TIMER_0:
 164   2                              num_ticks = ((UINT16)TH0) << 8;
 165   2                              num_ticks |= TL0;
 166   2                              num_ticks -= timer0_initial_count;
 167   2                              break;
 168   2                      case TIMER_1:
 169   2                              num_ticks = ((UINT8)TH1) << 8;
 170   2                              num_ticks |= TL1;
 171   2                              num_ticks -= timer1_initial_count;
 172   2                              break;
 173   2                      case TIMER_2:
 174   2                              num_ticks = T2COUNT;
 175   2                              num_ticks -= RCAP2;
 176   2                              break;
 177   2                      default:
 178   2                              return 0;
C51 COMPILER V9.60.0.0   CH552_TIMER                                                       04/18/2024 21:09:17 PAGE 4   

 179   2              }
 180   1              return num_ticks;
 181   1      }
 182          
 183          //HINT: stop the timer before using the delay functions
 184          //This function has an overhead of about 2.5us @ 24MHz
 185          void timer_short_delay(UINT8 timer, UINT16 num_ticks)
 186          {
 187   1              UINT16 initial_count = ~num_ticks + 1;
 188   1              switch(timer)
 189   1              {
 190   2                      case TIMER_0:
 191   2                              TL0 = (UINT8)initial_count;
 192   2                              TH0 = initial_count >> 8;
 193   2                              TF0 = 0;
 194   2                              TR0 = 1;
 195   2                              while(!TF0) {}
 196   2                              TR0 = 0;
 197   2                              return;
 198   2                      case TIMER_1:
 199   2                              TL1 = (UINT8)initial_count;
 200   2                              TH1 = initial_count >> 8;
 201   2                              TF1 = 0;
 202   2                              TR1 = 1;
 203   2                              while (!TF1) {}
 204   2                              TR1 = 0;
 205   2                              return;
 206   2                      case TIMER_2:
 207   2                              T2COUNT = initial_count;
 208   2                              TF2 = 0;
 209   2                              TR2 = 1;
 210   2                              while(!TF2) {}
 211   2                              TR2 = 0;
 212   2                              return;
 213   2                      default:
 214   2                              return;
 215   2              }
 216   1      }
 217          
 218          //HINT: use timer_set_period to specify the time between overflows
 219          void timer_long_delay(UINT8 timer, UINT16 num_overflows)
 220          {
 221   1              timer_overflow_counts[timer] = 0;
 222   1              timer_start(timer);
 223   1              while(timer_overflow_counts[timer] < num_overflows) {}
 224   1              timer_stop(timer);
 225   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    792    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
