C51 COMPILER V9.60.0.0   CH552_UART                                                        04/18/2024 21:09:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CH552_UART
OBJECT MODULE PLACED IN .\Objects\CH552_UART.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE CH552_UART.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\L
                    -istings\CH552_UART.lst) OBJECT(.\Objects\CH552_UART.obj)

line level    source

   1          #include "CH552.H"
   2          #include "System.h"
   3          #include "CH552_TIMER.h"
   4          #include "CH552_UART.h"
   5          #include "CH552_UART_FIFO.h"
   6          
   7          UINT8 uart_idle[2];
   8          
   9          void uart0_isr(void) interrupt INT_NO_UART0
  10          {
  11   1              if(RI)
  12   1          {
  13   2              RI = 0;
  14   2              uart_rx_push(UART_0, SBUF);
  15   2          }
  16   1          if(TI)
  17   1          {
  18   2              TI = 0;
  19   2              if(uart_tx_num_used(UART_0))
  20   2                  SBUF = uart_tx_pop(UART_0);
  21   2              else
  22   2                  uart_idle[UART_0] = 1;
  23   2          }
  24   1      }
  25          
  26          void uart1_isr(void) interrupt INT_NO_UART1
  27          {
  28   1              if(U1RI)
  29   1          {
  30   2              U1RI = 0;
  31   2              uart_rx_push(UART_1, SBUF1);
  32   2          }
  33   1          if(U1TI)
  34   1          {
  35   2              U1TI = 0;
  36   2              if(uart_tx_num_used(UART_1))
  37   2                  SBUF1 = uart_tx_pop(UART_1);
  38   2              else
  39   2                  uart_idle[UART_1] = 1;
  40   2          }
  41   1      }
  42          
  43          void uart0_init(UINT8 uart0_tim, UINT32 baud, UINT8 pin_map)
  44          {
  45   1              if(!baud)
  46   1              {
  47   2                      REN = 0;
  48   2                      ES = 0;
  49   2                      return;
  50   2              }
  51   1              
  52   1              switch(uart0_tim)
  53   1              {
  54   2                      case TIMER_0:
C51 COMPILER V9.60.0.0   CH552_UART                                                        04/18/2024 21:09:17 PAGE 2   

  55   2                              //Timer 0 can not be used for the UART!
  56   2                              return;
  57   2                      case TIMER_1:
  58   2                              uart_idle[UART_0] = 1;
  59   2                              PCON |= SMOD;
  60   2                              TMOD &= 0x0F;
  61   2                              TMOD |= bT1_M1;
  62   2                              TCLK = 0;
  63   2                              RCLK = 0;
  64   2                              T2MOD |= bTMR_CLK | bT1_CLK;
  65   2                              TR1 = 1;
  66   2                              TH1 = 256ul - FREQ_SYS / 16ul / baud;
  67   2                              SCON = 0x50;    //SM0 = 0, SM1 = 1, SM2 = 0, REN = 1
  68   2                              ES = 1; //enable interrupts
  69   2                              break;
  70   2                      case TIMER_2:
  71   2                              uart_idle[UART_0] = 1;
  72   2                              T2CON = 0x34;   //RCLK = 1, TCLK = 1, TR2 = 1
  73   2                              T2MOD |= bTMR_CLK | bT2_CLK;
  74   2                              RCAP2 = 65536ul - FREQ_SYS / 16ul / baud;
  75   2                              SCON = 0x50;    //SM0 = 0, SM1 = 1, SM2 = 0, REN = 1
  76   2                              ES = 1; //enable interrupts
  77   2                              break;
  78   2                      default:
  79   2                              return;
  80   2              }
  81   1              
  82   1              PIN_FUNC &= ~bUART0_PIN_X;
  83   1              PIN_FUNC |= pin_map;
  84   1      }
  85          
  86          void uart1_init(UINT32 baud, UINT8 pin_map)
  87          {
  88   1              if(!baud)
  89   1              {
  90   2                      U1REN = 0;
  91   2                      IE_UART1 = 0;
  92   2                      return;
  93   2              }
  94   1              
  95   1              uart_idle[UART_1] = 1;
  96   1              SCON1 = 0x30;   //U1SM0 = 0, U1SMOD = 1, U1REN = 1
  97   1              SBAUD1 = 256ul - FREQ_SYS / 16ul / baud;
  98   1              IE_UART1 = 1;   //enable interrupts
  99   1              
 100   1              PIN_FUNC &= ~bUART1_PIN_X;
 101   1              PIN_FUNC |= pin_map;
 102   1      }
 103          
 104          // Receive
 105          UINT16 uart_bytes_available(UINT8 uart)
 106          {
 107   1              return uart_rx_num_used(uart);
 108   1      }
 109          
 110          UINT8 uart_peek(UINT8 uart)
 111          {
 112   1              return uart_rx_peek(uart);
 113   1      }
 114          
 115          UINT8 uart_read_byte(UINT8 uart)
 116          {
C51 COMPILER V9.60.0.0   CH552_UART                                                        04/18/2024 21:09:17 PAGE 3   

 117   1              UINT8 popped;
 118   1      
 119   1              while(uart_rx_empty(uart));
 120   1      
 121   1              if(uart)
 122   1                      IE_UART1 = 0;
 123   1              else
 124   1                      ES = 0;
 125   1              popped = uart_rx_pop(uart);
 126   1              if(uart)
 127   1                      IE_UART1 = 1;
 128   1              else
 129   1                      ES = 1;
 130   1              return popped;
 131   1      }
 132          
 133          void uart_read_bytes(UINT8 uart, UINT8* dest, UINT16 num_bytes)
 134          {
 135   1              UINT16 num_remaining = num_bytes;
 136   1              UINT16 num_to_read = 0;
 137   1      
 138   1              while(num_remaining)
 139   1              {
 140   2                      num_to_read = uart_rx_num_used(uart);
 141   2                      if (num_to_read > num_remaining)
 142   2                      {
 143   3                              num_to_read = num_remaining;
 144   3                      }
 145   2      
 146   2                      if(uart)
 147   2                              IE_UART1 = 0;
 148   2                      else
 149   2                              ES = 0;
 150   2                      uart_rx_read(uart, dest, num_to_read);
 151   2                      if(uart)
 152   2                              IE_UART1 = 1;
 153   2                      else
 154   2                              ES = 1;
 155   2      
 156   2                      num_remaining -= num_to_read;
 157   2                      dest += num_to_read;
 158   2              }
 159   1      
 160   1              return;
 161   1      }
 162          
 163          UINT16 uart_read_bytes_until(UINT8 uart, UINT8 terminator, UINT8* dest, UINT16 num_bytes)
 164          {
 165   1              UINT16 num_remaining = num_bytes;
 166   1              UINT8 popped;
 167   1      
 168   1              while(num_remaining)
 169   1              {
 170   2                      if(uart_rx_empty(uart))
 171   2                              continue;
 172   2      
 173   2                      if(uart)
 174   2                              IE_UART1 = 0;
 175   2                      else
 176   2                              ES = 0;
 177   2                      popped = uart_rx_pop(uart);
 178   2                      if(uart)
C51 COMPILER V9.60.0.0   CH552_UART                                                        04/18/2024 21:09:17 PAGE 4   

 179   2                              IE_UART1 = 1;
 180   2                      else
 181   2                              ES = 1;
 182   2      
 183   2                      if(popped == terminator)
 184   2                              break;
 185   2      
 186   2                      --num_remaining;
 187   2                      *dest++ = popped;
 188   2              }
 189   1      
 190   1              return (num_bytes - num_remaining);
 191   1      }
 192          
 193          UINT16 uart_get_string(UINT8 uart, char* buf, UINT16 buf_size)
 194          {
 195   1              UINT16 bytes_read = 0;
 196   1              char received_data;
 197   1      
 198   1              --buf_size;     //leave space for the null byte
 199   1              while(bytes_read < buf_size)
 200   1              {
 201   2                      while(uart_rx_empty(uart)) {};
 202   2                      if(uart)
 203   2                              IE_UART1 = 0;
 204   2                      else
 205   2                              ES = 0;
 206   2                      received_data = (char)uart_rx_pop(uart);
 207   2                      if(uart)
 208   2                              IE_UART1 = 1;
 209   2                      else
 210   2                              ES = 1;
 211   2                      buf[bytes_read++] = received_data;
 212   2                      if(received_data == '\r' || received_data == '\n')
 213   2                              break;
 214   2              }
 215   1              buf[bytes_read] = '\0';
 216   1              return bytes_read;
 217   1      }
 218          
 219          // Send
 220          UINT16 uart_bytes_available_for_write(UINT8 uart)
 221          {
 222   1              return uart_tx_num_free(uart);
 223   1      }
 224          
 225          void uart_write_byte(UINT8 uart, UINT8 val)
 226          {
 227   1              if(uart_idle[uart])     //transmit buffer empty
 228   1              {
 229   2                      //send data directly to UART
 230   2                      if(uart)
 231   2                              SBUF1 = val;
 232   2                      else
 233   2                              SBUF = val;
 234   2                      uart_idle[uart] = 0;
 235   2              }
 236   1              else
 237   1              {
 238   2                      if(uart)
 239   2                              IE_UART1 = 0;
 240   2                      else
C51 COMPILER V9.60.0.0   CH552_UART                                                        04/18/2024 21:09:17 PAGE 5   

 241   2                              ES = 0;
 242   2                      uart_tx_push(uart, val);
 243   2                      if(uart)
 244   2                              IE_UART1 = 1;
 245   2                      else
 246   2                              ES = 1;
 247   2              }
 248   1      }
 249          
 250          UINT16 uart_write_string(UINT8 uart, char* str)
 251          {
 252   1              UINT16 len = 0;
 253   1      
 254   1              while(*str)
 255   1              {
 256   2                      if(uart_idle[uart])     //transmit buffer empty
 257   2                      {
 258   3                              //send data directly to UART
 259   3                              if(uart)
 260   3                                      SBUF1 = *str++;
 261   3                              else
 262   3                                      SBUF = *str++;
 263   3                              uart_idle[uart] = 0;
 264   3                      }
 265   2                      else
 266   2                      {
 267   3                              if(uart)
 268   3                                      IE_UART1 = 0;
 269   3                              else
 270   3                                      ES = 0;
 271   3                              uart_tx_push(uart, *str++);
 272   3                              if(uart)
 273   3                                      IE_UART1 = 1;
 274   3                              else
 275   3                                      ES = 1;
 276   3                      }
 277   2                      len++;
 278   2              }
 279   1              return len;
 280   1      }
 281          
 282          void uart_write_bytes(UINT8 uart, UINT8* src, UINT16 num_bytes)
 283          {
 284   1              UINT16 num_remaining = num_bytes;
 285   1              UINT16 num_to_write = 0;
 286   1      
 287   1              if(uart_idle[uart])     //transmit buffer empty
 288   1              {
 289   2                      //send data directly to UART
 290   2                      if(uart)
 291   2                              SBUF1 = *src++;
 292   2                      else
 293   2                              SBUF = *src++;
 294   2                      uart_idle[uart] = 0;
 295   2                      --num_remaining;
 296   2              }
 297   1      
 298   1              while(num_remaining)
 299   1              {
 300   2                      num_to_write = uart_tx_num_free(uart);
 301   2                      if(num_to_write > num_remaining)
 302   2                      {
C51 COMPILER V9.60.0.0   CH552_UART                                                        04/18/2024 21:09:17 PAGE 6   

 303   3                              num_to_write = num_remaining;
 304   3                      }
 305   2      
 306   2                      if(uart)
 307   2                              IE_UART1 = 0;
 308   2                      else
 309   2                              ES = 0;
 310   2                      uart_tx_write(uart, src, num_to_write);
 311   2                      if(uart)
 312   2                              IE_UART1 = 1;
 313   2                      else
 314   2                              ES = 1;
 315   2                      num_remaining -= num_to_write;
 316   2                      src += num_to_write;
 317   2              }
 318   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1457    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
